
### Garbage Collection은 뭔가?
메모리 관리를 자동화하는 매커니즘이다. 사용되지 않는 (아무곳에서도 참조하고있지 않는 상태인) 메모리를 자동으로 식별하고 회수하여 메모리 누수와 같은 문제를 방지한다.

- 힙메모리 : JVM이 관리하는 Runtime Data Area로 든 객체가 할당되는 공간이다. 힙메모리는 크게 두 부분으로 나뉜다.
    - Young Genaration : 새로 생성된 객체가 할당되는 공간으로, 더 작은 영역
    - Old Generation : Young Generation에서 살아남은 객체가 이동하는 공간으로, 더 큰 영역

> GC는 대부분의 객체는 빠르게 사라지고, 오래 살아남는 객체는 적다는 가설에 기반한다.
> 이 가설을 바탕으로 GC는 Young Generation과 Old Generation을 구분하여, 더 효율적인 메모리를 관리한다.


### GC의 동작방식 (매우 간단히, 왜냐하면 구현체 하나 정해서 자세하게 알아볼거기 때문)

##### A) 단계
1. Marking : 현재 사용중인 (어딘가에서 아직 참조중인) 객체를 식별한다. 이 과정에서 도달 가능한 객체 그래프를 탐색하여 표시한다.
2. Sweeping : 더 이상 사용되지 않는 객체를 수집하여 메모리를 해제한다. 이 단계에서 힙 메모리의 사용되지 않는 영역을 회수한다.
3. Compacting : 일부 GC 알고리즘은 메모리 파편화를 줄이기 위해 메모리를 압축하여 사용중인 객체를 힙 안쪽으로 이동시킨다.

##### 객체 그래프란?
> 객체들간의 참조관계를 나타내는 구조이다. 이 그래프를 통해 GC는 어떤 객체가 여전히 사용중인지, 어떤 객체가 더이상 필요하지 않은지 결정한다.

###### 객체 그래프의 구성요소
- 루트 집합 (Root Set) : GC의 시작점이다. 일반적으로 스택에 있는 지역변수, 클래스의 static 필드, JNI(Java Native Interface) 참조 등이 포함된다.
- 객체 (Object) : 힙 메모리에 할당된 개별 객체들이다.
- 참조 (Reference) : 객체 간의 연결이다. 한 객체가 다른 객체를 참조할 대 이를 화살표로 표시할 수 있다.

한마디로 리전 내 인스턴스 변수들을 저장하는 공간에서 참조하는 변수들의 메모리 주소값을 가지고 있고 이것으로 탐색가능한 구조가 만들어짐.


> [!question] 루트 집합이 GC의 시작점이라고 하는데 정확히 어디를 말하는 거지?
> JVM에서 직접 접근할 수 있는 변수와 객체들의 모음으로, 여기에서부터 객체 그래프 탐색이 시작된다.
>
> **구성요소**
> - JVM 스택의 지역 변수 및 매개변수
> - JVM 레지스터
> - 클래스 로더에서 로드된 클래스의 static 필드
> - JNI(Java Native Interface) 참조
>
> ![[Pasted image 20240720192836.png]]
> 출처: https://www.freecodecamp.org/news/garbage-collection-in-java-what-is-gc-and-how-it-works-in-the-jvm/
>
> **루트 집합에 추가되는 시점**
> - JVM이 시작되고 static 변수를 초기화할 때 새 객체를 할당하면 힙메모리에 생성되고, 루트집합에 추가됨
> - main 메서드 실행되면서 한줄한줄 실행할 때 new 키워드를 만나면 새 객체를 생성하여 메모리에 할당하고, 루트 집합에 추가됨. (다만 객체 내 필드는 루트집합에 포함되지 않음. 왜냐면 루트집합에 추가되어잇는 객체에서 연결되어있어 도달할 수 있기 때문)
>
> **루트 집합의 저장위치**
> JVM 내에 다양한 영역에 걸쳐 저장됨
> - JVM 스택 : 스택 프레임에 있는 로컬 변수 테이블이 루트집합의 일부가 됨
> - JVM 레지스터: 메서드 호출시 사용되는 특정 레지스터
> - 클래스 로더에 로드된 클래스의 static 필드 : static 변수들 초기화할 때 클래스 로더가 로드한 PermGen 또는 Metaspace(Java9 이상) 영역에 저장되고 static 변수들은 루트집합의 일부가 됨
> - JNI(Java Native Interface) 참조: 네이티브 코드에서 Java 객체를 참조하는 경우, 이 참조들은 JNI 핸들 테이블에 저장되어 루트집합에 일부가 됨


> [!question] 그럼 GC 루트가 모여있는게 아니라 각 위치에 분산되어 있다는건데 더이상 참조하지 않는다는 것(dead)을 어느시점에 판단하지?
>

> [!question] 지역변수가 가득찼을 때 GC 루트에서 빠지는 시점
> - 메서드가 종료되었을 때
> - 블록이 종료되었을 때 (if, for, switch ...)


##### B) GC 알고리즘 (==각각 어디에서 사용되는지 구체적인 예시 조사==)
- Mark-and-Sweep: 가장 기본적인 GC 알고리즘으로, 두 단계를 통해 사용되지 않는 객체를 수집
- Copying : Young Generation에서 주로 사용되는 알고리즘으로, 살아남은 객체를 새 공간으로 복사하고 나머지 메모리를 해제
- Mark-Compact : Mark-and-Sweep의 확장으로, 객체를 한쪽으로 이동시켜 메모리 파편화를 줄인다.
- Generational GC : 객체를 세대별로 분류하여 Young Generation과 Old Generation에서 각각 다른 방식으로 GC를 수행
- Concurrent GC : 애플리케이션 실행과 동시에 GC를 수행하여 애플리케이션의 중단시간을 줄인다.

##### C) Stop-the-World 이벤트
- GC는 일반적으로 모든 애플리케이션 스레드를 일시중지하고 실행된다. 이 중단 시간을 "Stop-the-World" 이벤트라고 한다. **GC 알고리즘 목표 중 하나는 이 중단시간을 최소화하는 것이다.**

##### D) GC 튜닝
- 애플리케이션 성능을 최적화하기 위해 GC의 동작을 조정할 수 있다. JVM 옵션을 통해 힙메모리 크기, GC 알고리즘 선택, GC 로그 설정 등을 조정할 수 있다. (==실무에서 GC 동작을 조정할일이 자주 발생하나?==)


### GC는 왜 존재하는가? 무슨 이유에서 생겨났는가?
C나 C++같은 언어에서는 개발자가 직접 메모리 할당과 해제를 해주어야 했다. (free() 메서드)
그러나 이런방식은 아래 `메모리 누수`, `유효하지 않은 포인터 접근`, `이중해제`, `개발 복잡성 증가(프로그래머가 직접하면 코드가 복잡해지고, 버그 발생 가능성이 높아짐)`, `병행처리 어려움(멀티스레드 환경에서 수동메모리 관리는 각 스레드가 메모리 할당과 해제를 독립적으로 해야하므로, 동기화 경쟁상태가 발생할 수 있음)` 등의 실수로 버그의 원인이 되곤 했다. 일반적으로 버그는 재현가능하고 가깝고 쉽게 접근할 수 있는 곳부터 발견할 수 있는 가능성이 높은데 메모리 관련된 버그는 쉽게 들여다보거나 재현하기까지 어려운 경우가 많았다.
GC는 이러한 문제를 자동화된 방식으로 해결하여 메모리 관리의 복잡성을 줄이고, 안정성과 성능을 높였다.
###### 병행처리 어려움에 대한 구체적인 예시
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef struct {
    int data;
} MyObject;

void* thread_function(void* arg) {
    MyObject* obj = (MyObject*)malloc(sizeof(MyObject));
    obj->data = 42;

    // 객체를 사용 (여기서는 단순히 데이터 출력)
    printf("Thread %ld: obj->data = %d\n", (long)arg, obj->data);

    // 메모리 해제
    free(obj);

    return NULL;
}

int main() {
    pthread_t threadA, threadB;

    // 두 개의 스레드를 생성
    pthread_create(&threadA, NULL, thread_function, (void*)1);
    pthread_create(&threadB, NULL, thread_function, (void*)2);

    // 스레드가 종료될 때까지 대기
    pthread_join(threadA, NULL);
    pthread_join(threadB, NULL);

    return 0;
}
```

1. 경쟁상태
    - `ThreadA`와 `ThreadB`가 거의 동시에 `malloc`을 호출하여 메모리를 할당받고 각각 객체를 사용한 후 `free`를 호출한다.
    - 두 스레드가 동일한 객체를 참조하고 있다면 하나의 스레드가 메모리를 해제한 후 다른 스레드가 이미 해제된 메모리를 참조하려고 할 수 있다. 이는 **잘못된 메모리 참조**로 이어진다.
2. 동기화 문제
    - 두 스레드가 같은 객체를 동시에 수정하려고 하면, 데이터 무결성이 보장되지 않을 수 있다.
    - 두 스레드가 동일한 메모리 위치에 데이터를 쓰려고 하면, 마지막으로 쓰여진 값만 유지된다.
3. 이중 해제
    - 두 스레드가 동일한 객체를 두 번 해제하려고 하면 **이중해제** 문제가 발생한다. 이는 프로그램 충돌을 일으킬 수 있다.


## G1 GC (Garbage-First GC)

### 선택한 이유
- Java9버전부터 디폴트 GC 방식이라고 해서 선택함. 실무에서 많이 사용되는 Java8의 디폴트 GC 방식인 Parallel GC도 알아보고 싶었지만 Java8은 출시된지 오래되어 Java8을 사용한다면 버전 업을 해야하는 상황이기 때문에 G1 GC를 우선순위로 올렸다.


### G1 GC가 무엇인가?
> Java HotSpot VM[^1]에서 제공하는 서버 스타일의 GC로, 대규모 힙 메모리와 낮은 GC 지연시간을 요구하는 애플리케이션. 힙 메모리를 여러개의 독립된 영역(region)으로 나누고, 가장 먼저 회수할 가치가 높은 영역부터 처리하는 알고리즘이다.

> 크기가 동일한 힙 리전 세트로 분할되며, 각 리전은 연속적인 가상 메모리 범위이다. G1은 힙 전체의 객체 생존 여부를 결정하기 위해 동시 글로벌 마킹(Concurrent Global Marking) 단계를 수행한다. 마킹 단계가 완료되면 G1은 대부분이 비어있는 리전들을 파악한다. 그리고 이러한 리전들에서 먼저 수집작업을 하여 큰 양의 여유공간을 확보한다. 이러한 방식이 가비지 컬렉션이 "Garbage-First" 라고 불리는 이유다.
> 이름에서 알수 있듯이, G1은 회수 가능한 객체, 즉 가비지가 많은 가능성이 있는 힙 영역에 집중하여 수집 및 압축 작업을 수행한다.


1. Region 기반 힙 관리: 힙메모리를 동일한 크기의 여러개의 region으로 나눈다. 각 region은 Young Generation과 Old Generation으로 동적으로 할당될 수 있다.
2. Young Generation과 Old Generation
    - Young Generation: 주로 새로운 객체가 할당되는 공간이며, 여러개의 region으로 구성됨
        - Eden리전과 Survivor리전으로 구성된다.
        - 새로운 객체는 Eden 리전에 할당 되며, Minor GC가 발생할 때 살아남은 객체는 Survivor 리전으로 이동한다.
    - Old Generation: `Young Generation`에서 살아남은 객체들이 이동되는 공간
        - 여러번의 Minor GC를 거친 후에도 살아남은 객체는 Old Generation 리전으로 이동한다.
        - Old Generation 리전은 수명이 긴 객체들을 저장하며, Major GC가 발생할 때 수집된다.
3. Concurrent and Parallel Phases
    - G1 GC는 병행과 병렬을 여러단계로 수행하여 Stop the World를 최소화한다.
4. Collection Set (CSet)
    - 회수할 region의 집합을 의미한다. G1 GC는 주로 Young Generation의 region을 우선적으로 수집하고, 필요에 따라 Old Generation과 region도 포함한다.

![[Pasted image 20240719160635.png]]
(출처: https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html)

- 파란색: Old
- 빨간색 박스: Young
- 빨간색 박스 중에 'S' 포함 영역: Surviving object
- H 파란색: Humongous Object. 영역의 절반보다 크고 특별히 처리되는 큰 객체가 포함됨 (https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#humongous)
- 회색: 빈 영역

#### G1 GC 사용을 권장하는 경우
우선 큰 힙이 필요하고 제한된 GC 지연시간을 요구하는 애플리케이션을 실행하는 사용자에게 솔루션을 제공한다. 이는 약 6GB 이상의 힙 크기와 0.5초 이하의 안정적이고 예측 가능한 일시 정지 시간을 의미한다.
(https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html)



#### Old Generation과 Young Generation은 영역이 물리적으로 구분되어있는게 아닌가? 힙메모리 내에서 바둑판같이 region이 여기저기 저장되어 있나?

다른 GC는 물리적으로 분리된 영역을 사용한다. 하지만 G1 GC는 물리적으로 분리된 영역으로 관리되지 않는다.
힙 메모리를 동일 크기의 여러 개의 region으로 나누고, 각 리전은 Young 또는 Old Generation에 속할 수 있다.
물리적으로 분리되지는 않았지만 논리적으로 Young Generation과 Old Generation을 나누어 관리한다.

```
+-------+-------+-------+-------+-------+
| Eden  | Eden  | Old   | Eden  | Old   |
+-------+-------+-------+-------+-------+
| Old   | S0    | Eden  | Old   | Eden  |
+-------+-------+-------+-------+-------+
| Eden  | Old   | S1    | Eden  | Old   |
+-------+-------+-------+-------+-------+
| Old   | Old   | Eden  | S0    | Eden  |
+-------+-------+-------+-------+-------+
```


#### 힙메모리가 초기화될 때 여러개의 리전들이 각각 어떤 용도로 사용될지 미리 정해져있는건가?
> 힙메모리가 초기화될 때 G1 GC는 힙메모리를 고정크기의 여러 리전으로 나누지만, 이 리전들이 Eden, Survivor, Old 중 어느 용도로 사용될지는 미리 정해져 있지 않고, 객체가 생성되거나 필요에 따라 동적으로 결정된다.

동적 리전 할당
1. 새로운 객체가 생성될 때, G1 GC는 Eden 영역에 리전을 할당한다.
    1. 처음에는 Eden 영역에 필요한 만큼 리전을 할당한다.초기에는 객체가 생성되지 않았기 때문에 대부분의 리전은 할당되지 않은 상태로 남아있다.
2. 애플리케이션을 실행하면서 객체가 생성되면 G1 GC는 동적으로 Eden, Survivor, Old Generation 용도로 리전을 동적으로 할당한다. 예를 들어 Eden 리전이 가득차면 새로운 리전을 Eden 용도로 할당할 수 있다.
3. MinorGC가 발생하여 생존객체가 Survivor 영역으로 이동해야할 때, Survivor 용도로 새로운 리전을 할당할 수 있다.
4. 마찬가지로, Old Generation이 필요할 때 Old Generation 용도로 리전을 할당한다.

2048개까지 생성가능
**리전의 크기**
- 힙 메모리의 크기에 따라 자동으로 결정되며, 일반적으로 1MB에서 32MB 사이이다.

#### Eden1이 가득찼으면 Eden2나 Eden3이 가득차지 않았어도 MinorGC에 의해 다 비워지나?
> Minor GC가 트리거 되는 기준은 Eden 영역 전체가 가득 찼을 때이다. Eden 영역은 여러개의 리전으로 구성되어있고 이러한 모든 리전이 가득 찼을 때 Minor GC가 발생한다. Eden 영역의 특정 리전 중 하나만 가득 찼다고 해서 Minor GC가 트리거되지는 않는다.

**모니터링**
- Eden 영역이 할당된 모든 바이트가 사용되면, JVM은 Eden 영역이 가득찼다고 판단한다.
- G1 GC는 Eden 영역의 사용상태를 지속적으로 모니터링한다.

**Minor GC 트리거**
1. Eden 영역의 전체처리
    - Eden 영역의 모든 리전이 가득차게되면 Minor GC가 트리거된다.
    - Minor GC는 Eden 영역의 모든 리전을 대상으로 한다.
2. 생존 객체 이동
    - Eden 영역에 있는 모든 객체를 스캔하여 GC루트에서 도달할 수 있는 생존객체를 식별한다.
    - 생존 객체는 Survivor 영역으로 이동한다.  Survivor 영역도 포화상태면, 일부 객체는 Old Generation으로 이동한다.
3. Eden 영역 비우기
    - Eden 영역의 모든 리전은 Minor GC가 완료된 후 비워진다.
    - 살아남지 않은 객체는 가비지로 간주되어 제거된다.

##### Eden 영역도 여러 region들로 있을텐데 객체를 생성할 때 어느 eden region으로 할당할지 무슨 기준으로 정하지?

**객체 할당 기준**
1. 충분한 빈공간이 있는지 확인
2. 균형잡힌 할당
    - G1 GC는 리전간에 균형잡힌 메모리 사용을 유지하려고 한다.
    - 특정 Eden 리전에만 집중적으로 할당되지 않도록 여러 Eden 리전에 균등하게 할당하려고 한다.

**객체 할당과정**
1. 새로운 객체 생성 요청
    - 애플리케이션에서 새로운 객체를 생성하라는 요청이 발생한다.
2. Eden 리전 선택
    - G1 GC는 현재 사용가능한 Eden 리전 중에서 충분한 빈공간이 있는지 찾는다.
    - 충분한 공간이 있는 리전이 여러개 있을 경우, G1 GC는 균형잡힌 할당을 위해 다양한 전략을 사용하여 리전을 선택한다.
3. 객체 할당
    - 선택된 Eden 리전에 새로운 객체가 할당된다.
    - 리전의 메타데이터가 업데이트 되어 사용된 공간이 증가한다.
4. 리전이 가득 찰 경우
    - 선택된 Eden 리전이 가득차면 G1 GC는 다음 할당을 위해 다른 Eden 리전을 선택한다.
    - 모든 리전이 가득차면 Minor GC가 트리거된다.


##### Eden 영역이 가득찼을 때 빈 Region을 추가로 Eden영역으로 할당할지 minorGC로 모든 Eden 영역을 비워낼지 어떻게 판단하지?

###### 판단기준
1. 힙메모리의 여유공간
    1. 힙 메모리의 충분한 여유공간이 남아있는 경우, 새로운 리전을 Eden 영역으로 할당하여 사용할 수 있다.
    2. 힙 메모리가 제한적이거나 이미 상당 부분 사용된 경우, Minor GC를 트리거하는 것이 더 적절할 수 있다.
    - 힙 메모리가 충분하다고 판단하는 기준
        - 가비지 컬렉터의 설정 및 현재 메모리 사용상황에 따라 다르다.
        - InitialtingHeapOccupancyPercent(IHOP)
            - 힙 메모리 사용률이 어느정도 도달했을 때, `-XX: InitialHeapOccupancyPercent` 옵션, 예를 들어 IHOP 값이 45%로 설정되어 있다면, 힙 사용률이 45%에 도달했을 때 GC가 트리거가 될 수 있다.
        - 가용 리전 수
            - 힙 전체에서 사용되지 않은 리전수가 충분한지 여부를 평가하여 사용 가능한 리전의 수가 충분하지 않으면 GC를 트리거할 가능성이 높아진다.
        - Survivor 및 Old Generation의 상태
            - Survivor 영역과 Old Generation의 사용률도 고려된다. Survivor 영역이 포화상택이거나 Old Generation에 여유공간이 적다면, GC를 통해 메모리 회수가 필요하다.
        - 메모리 할당 속도 및 객체 수명
            - 애플리케이션의 메모리 할당 속도와 객체의 수명도 중요한 역할을 한다. 객체가 빠르게 생성되고 단기적으로 소멸된다면, Eden 영역이 빨리 차게 된다.
            - ==G1 GC는 애플리케이션의 메모리 할당 패턴을 기반으로 최적의 GC 시점을 예측한다.==


##### 동일한 크기의 region들로 구성되어 해당 크기 이상의 것은 어떻게 할당되지?
Humongous Resion이라 부르며, 일반적으로 리전의 50% 이상의 큰 객체를 저장하는데 사용되며, 이러한 객체는 하나이상의 연속된 리전에 할당된다. 이는 일반적인 객체 할당 방식과 다르며, 메모리 단편화를 줄일 수 있도록 도와준다.
이 리전은 Old Generation으로 간주되며, 이는 이러한 객체들이 긴 수명을 가질 가능성이 높기 때문이다.

문제점은 humongous는 Old GC에서 수집되어서 수명이 짧은 객체일 경우 참조하고 있지 않은 시점이 훨씬 지나서 회수될 수 있다.

#### 각 영역으로 구분되어있지 않으면 어떻게 Old Generation과 Young Generation을 식별할 수 있지?
각 리전에는 해당 리전이 Young Generation인지 Old Generation인지를 나타내는 메타데이터가 포함되어 있다. G1 GC는 이 메타데이터를 기반으로 리전의 타입을 인식하고 관리한다.
G1 GC는 힙 메모리 내의 리전들을 지속적으로 모니터링한다. 객체가 생성되거나 이동될 때, 해당 객체가 할당된 리전의 상태 정보가 갱신된다.

#### 리전의 구성 정보
- 리전의 메타데이터
    - 해당 영역이 Young Generation인지 Old Generation인지 사용중인지, 미사용중인지 판단함. 그리고 해당 영역에 얼마나 많은 메모리가 사용되고 있는지 추적한다.
    - 각 영역에는 현재 사용중인 바이트 수를 추적하는 메타데이터가 포함되어 있다. 그리고 객체가 Eden 영역에 할당될 때마다, 사용된 메모리 바이트 수가 증가한다.
    - Eden 영역의 사용량이 증가할 때마다 JVM은 이를 모니터링하여 사용량이 영역의 총 용량을 초과하는지를 확인한다.
    - 포함 정보
        - 영역의 시작 주소와 크기: 각 영역의 물리적 메모리 주소와 크기 정보
        - 현재 사용량: 영역에 할당된 메모리 바이트 수이다. 객체가 할당되거나 해제될 때마다 이 값이 업데이트된다.
        - 영역 타입: 해당 영역이 Eden, Survivor, 또는 Old Generation 중 어느 영역에 속하는지 나타난다.
- 객체
    - 객체 헤더
        - 각 객체의 메타데이터를 저장. 객체의 클래스 정보, 해시코드, 동기화 상태등이 포함됨
            1. 클래스 정보: 객체의 클래스에 대한 포인터. 이 포인터를 통해 객체의 메서드와 필드 정보를 얻을 수 있다.
            2. 해시코드: 객체의 해시코드. 해시코드는 주로 객체를 해시 테이블에 저장하거나 비교할 때 사용된다.
            3. 락정보 : 객체가 동기화에 사용될 경우, 락 상태를 저장. 예를 들어 `synchronized` 블록에 진입할 때 이 정보를 사용한다.
            4. GC 상태: 객체가 가비지 컬렉션 과정에서 사용되는 마크 비트나 세대 정보 등이 포함될 수 있다.
            5. 객체의 나이 : 리전을 이동할 때마다 업데이트됨
    - 객체 필드
        - 실제 데이터가 저장되는 부분. 객체의 인스턴스 변수들이 저장됨


#### 객체가 이동해서 메모리주소가 바뀌었다면 이동한 객체가 어디어디에 참조되고 있는지 어떻게 추적해서 업데이트해주는거지?
> GC 루트부터 전체를 탐색하지 않고도 효율적으로 참조를 추적하고 업데이트한다.
> **1. Remembered Sets**
> 	G1 GC는 Remembered Sets(RSets)를 사용해서 각 리전에서 어떤 객체가 참조되고 있는지를 추적한다.
> 	Remembered Sets는 힙의 특정 리전이 다른 리전의 객체를 참조할 때마다 해당 참조 정보를 저장한다.
> 	이를 통해 특정 리전의 객체가 이동할 때, 해당 객체를 참조하는 위치를 효율적으로 찾아서 참조를 업데이트할 수 있다.
>
> 	역할
> 	- 특정 리전의 객체가 다른 리전의 객체를 참조하는 경우, 그 정보를 RSets에 저장한다. 
> 	- 그리고 객체가 이동할 때, RSets를 사용하여 해당 객체를 참조하는 모든 위치를 찾아서 참조를 업데이트한다. (예시 필요)
> **2. Card Table**
> 	G1 GC는 Card Table을 사용하여 객체 참조의 변경을 추적한다. 힙메모리는 여러개의 카드로 나누어지며, 각 카드는 특정 메모리 범위를 나타낸다. Card 상태는 Clean과 Dirty로 표시될 수 있고, 객체 참조가 변경될 때마다 해당 카드는 '**Dirty**' 상태로 표시되고 업데이트가 되면 Clean으로 다시 업데이트된다.
>
> 	역할
> 	- 참조 변경 추적: 객체 참조가 변경될 때마다 해당 카드를 Dirty 상태로 표시한다.
> 	- 효율적인 스캔: GC는 Dirty 카드만 스캔하여 참조변경을 추적하고 업데이트한다.
>
> **객체 이동 및 참조 업데이트 과정**
> 1. 객체이동: 객체를 새위치로 이동한다.
> 2. 이동한 객체를 참조하는 모든 위치를 찾아서 업데이트한다.
     > 	1. 이동한 객체를 참조하는 모든 리전을 Remembered Sets를 통해 찾는다.
> 	2. 해당 리전의 객체 참조를 새로운 위치로 업데이트한다.
> 	3. Card Table 사용: Dirty 상태 카드만 스캔하여 참조 업데이트를 효율적으로 수행한다.

==업데이트 예시==






#### static 변수에 할당된 객체같은 경우 잘 안바뀌니까 한번에 Old Generation가도 되는거 아닌가?
보통은 똑같이 Eden -> Survivor -> Old Generation으로 이동한다. 하지만 static변수의 경우는 일반적으로 애플리케이션이 실행되는동안 오래남는 경우가 많아서 결국 Old Generation까지 간다.


### G1 GC의 단계별 수집 과정
각 단계는 동시 또는 병렬로 수행될 수 있다.

(young only)
#### Minor GC
> **트리거 조건**
> - Eden 영역이 가득 찼을 때: 새 객체가 Eden 영역에 할당될때, 공간이 부족하면 Minor GC가 트리거된다.
>
> **주기**
> - 일반적으로 빈도가 높으며, 몇 초 또는 수 초 단위로 발생한다.

##### 1. Initial Mark (초기 마킹)
- GC 루트에서 시작하여 '**직접 참조**'되는 모든 객체를 마킹한다.
- **이 단계는 매우 짧은 Stop the World 이벤트 동안 수행됨**.
- 이 시점에 애플리케이션 스레드가 다시 시작됨
###### Stop the World를 해야하는 이유
> 애플리케이션의 일관된 상태를 보장하고, 객체 참조 그래프를 정확하게 마킹하기 위해서이다.
> 1. 객체 참조의 일관성 보장
     > 	1. GC가 실행되는동안 애플리케이션 스레드가 계속 실행되게 되면 객체 참조가 변경될 수 있다. 객체 참조가 변경되면, GC가 정확한 객체 그래프를 마킹할 수 없게 되어, 마킹되지 않는 객체가 가비지로 잘못처리되거나, 참조되지 않은 객체가 생존 객체로 잘못처리될 수 있다.
> 2. GC 루트의 정확한 마킹
     > 	1. GC 루트는 다양한 위치에 존재하며, 애플리케이션 스레드가 실행 중일 때 이들 참조가 변경될 수 있다.
> 3. 데이터 무결성 유지
     > 	1. GC가 객체를 이동하거나 객체의 메타데이터를 변경하는동안 애플리케이션 스레드가 실행되면 데이터 무결성이 손상될 수 있다. STW를 통해 데이터 무결성을 유지하고, 안전하게 객체를 마킹하고 이동할 수 있다.

###### STW하는동안 애플리케이션 스레드가 멈추면 다시 시작될 때 하던부분부터 시작할 수 있는건가?
> 애플리케이션 스레드가 중지된 지점부터 작업을 재개할 수 있다. JVM의 스레드 스케줄링과 문맥 전환 매커니즘 덕분에 가능하다.
>
> **문맥 전환과 STW**
> 1. STW 시작 : 모든 애플리케이션 스레드는 현재 실행중인 작업을 중지하고, JVM은 각 스레드의 상태(레지스터, 스택포인터, 프로그램 카운터 등)을 저장한다.
     > 	- 스레드 상태저장
            > 		- 스레드 컨트롤 블럭 (TCB, Thread Control Block):
> 			- 각 스레드의 상태(레지스터 값, 스택포인터, 프로그램 카운터 등) 을 저장하는 데이터 구조이다.
               > 			- JVM은 TCB를 사용하여 스레드가 중지된 지점을 정확히 기억한다.
> 		- 스택과 레지스터 : JVM은 스레드의 호출 스택과 레지스터 상태를 캡처하여 저장한다.
> 		- JVM 내부 메타데이터: JVM은 스레드의 상태와 관련된 추가 메타데이터를 유지한다.
> 2. GC 작업 수행: GC 작업(Initial Mark)이 수행된다. 이 동안 JVM은 애플리케이션 스레드 상태를 변경하지 않는다.
> 3. STW 종료 : GC 작업이 완료됨녀 JVM은 이전에 저장된 상태를 복원하고 애플리케이션 스레드를 다시 시작한다.

##### 2. Root Region Scanning (루트 리전 스캐닝)
- Survivor 영역과 Old Generation에서 Young Generation의 객체들을 참조하고 있는 모든 참조를 확인한다. (Old Generation, Survivor --> Young Generation) 이 여부를 마킹한다.
- 애플리케이션 스레드와 병행하여 수행됨. Old Generation의 루트부터 시작하여 참조를 추적함

###### 애플리케이션 스레드와 병행하여 수행됨
> 애플리케이션이 실행되는동안 GC가 동시에 살아있는 객체를 마킹하는 작업을 수행한다. 이 단계는 Stop the World를 피하기 위해 설계되었다.
> 애플리케이션 스레드가 실행되는 동안, GC 스레드가 병행하여 힙을 스캔하고 살아있는 객체를 마킹한다. > 이는 기존 Mark-and-Sweep 방식과 달리, 긴 시간동안 애플리케이션을 멈추지 않고 마킹작업을 진행할 수 있다.
>
> 병행 작업을 하면 중단시간을 감소시키고, 중요한 실시간 애플리케이션에서 성능저하를 방지한다.

##### 3. Concurrent Marking (동시 마킹)
- Young Generation의 '**모든 객체**'를 스캔하여 마킹한다.
    - Young Generation에 있는 객체들을 재귀적으로 스캔하면서 참조되는 모든 객체를 마킹한다.
- 애플리케이션 스레드와 병행하여 수행됨. 이 단계가 시간이 가장 많이 소요됨

##### 4. Remark (재마킹)
- Concurrent Marking단계 수행하는동안 애플리케이션이 실행되면서 변경된 참조를 처리한다.
    - Card 테이블에서 Dirty상태인 카드를 스캔하여 해당 부분을 다시 마킹한다.
- Concurrent Marking단계에서 놓쳤을 수 있는 참조를 보완한다.

##### 5. Cleanup (정리)
- 마킹되지 않은 객체(더이상 참조되지 않은 객체)를 식별하여 가비로 처리한다.
- 살아남은 객체는 Survivor 영역으로 이동하고 필요시 Old Generation으로 승격한다.

##### 보통 몇번정도의 Minor GC에서 살아남아야 Old Generation으로 승격될까?
JVM의 가비지 컬렉터 설정에 따라 다를수 있다.
1. Survivor 영역의 크기와 구성
    - 객체가 Eden 영역에서 살아남으면 Survivor 영역 중 하나로 이동하고, 그 다음 Minor GC에서 또 다른 Survivor 영역으로 이동하는 식으로 반복된다.
2. 객체의 나이
    - 객체는 각 Minor GC를 통과할 때마다 나이를 하나씩 먹는다.
    - `-XX:MaxTenuringThreshold` 옵션을 사용하여 객체가 Old Generation으로 승격되는데 필요한 최대 나이를 설정할 수 있다.
    - 기본 값은 15이다. 이 값은 JVM마다 다를 수 있고, 일반적으로 15번의 Minor GC를 통과한 객체는 Old Generation으로 승격된다.
3. 동적 임계값
    - 힙메모리가 부족할 때는 객체가 더 빨리 Old Generation으로 승격될 수 있다.

기본 승격과정
1. 객체 생성: 객체가 처음 생성되면 Eden 영역에 할당된다.
2. 첫번째 Minor GC: Eden 영역의 객체가 살아남으면 첫번째 Survivor 영역(S0)으로 이동하고 나이가 1이 된다.
3. 두번째 Minor GC: 첫번째 Survivor 영역(S0)의 객체가 살아남으면 두번째 Survivor 영역(S1)으로 이동하고 나이가 2가된다.
4. 이후 Minor GC: 객체가 계속해서 살아남으면 Survivor 영역을 반복해서 전환해가며 나이가 증가한다.
5. Old Generation으로 승격: 객체의 나이가 설정된 임계값(기본값 15)에 도달하면 Old Genration으로 승격된다.

##### Minor GC가 통과할 때 Survivor 영역을 번갈아가면서 이동시키는 이유
1. **메모리 단편화 방지** : 메모리 단편화가 발생하면, 연속된 메모리 블록을 할당하기가 어려워지기 때문에 메모리 효율이 떨어짐
    - 객체를 이동시킴으로써 메모리의 연속된 공간을 확보할 수 있다.
    - Eden 과 Survivor 영역 사이를 번갈아가면서 이동할 때, 사용되지 않는 객체(가비지)는 자연스럽게 제거된다.
2. **객체의 수명 추적 및 승격** : 객체를 이동시킬 때 객체의 수명을 추적한다. 객체가 여러번의 MinorGC를 거쳐도 살아남으면, 이 객체는 장기 생존 객체로 간주되고 Old Generation으로 승격될 필요가 될 필요가 있다.
    - 수명 관리 : 객체가 Eden 영역에서 Survivor 영역으로, Survivor 영역에서 다른 Survivor 영역으로 이동하는 과정을 통해 객체의 수명이 추적된다.
    - 나이 업데이트: 각 Minor GC를 통과할 때마다 객체의 나이가 증가하며, 승격 임계 값에 도달하면 Old Generation으로 이동한다.
3. **효율적인 GC 작업** : Survivor 영역을 번갈아가면서 사용하는 것은 GC 작업을 효율적으로 수행하기 위함이다. 이는 GC의 작업량을 줄이고, 힙 메모리 관리를 단순화합니다.
    - GC 작업량 감소: 객체를 이동하면서 참조되는 객체들만 남기고 나머지를 제거함으로써 GC가 처리해야할 객체 수가 줄어든다.


(Space Reclamation)
### Mixed GC
> Young Generation과 Old Generation의 일부 리전을 함께 수집하며, Concurrent Marking 후에 발생한다. Mixed GC는 G1 GC의 고유 기능으로, 애플리케이션 중단 시간을 최소화하면서 효율적인 가비지 컬렉션을 수행하는 것을 목표로 한다.
>
> **트리거 조건**
> - Concurrent Marking 완료 후 : Old Generation의 객체가 얼마나 많이 살아남았는지 파악한 후에 Mixed GC가 트리거된다.
> - 힙 사용 임계값 도달: Old Generation의 사용률이 설정된 임계값에 도달하면 Mixed GC가 트리거될 수 있다.
>
> **주기**
> - Concurrent Marking 후에 Old Generation의 일부 리전을 수집하며, 몇분에서 몇시간 단위로 발생할 수 있다.

##### 수집단계는 Minor GC와 동일하고, Cleanup이 다름
- 가비지를 제거하고, 생존객체를 이동 및 압축한다.
- Mixed GC는 Young Generation과 Old Generation의 일부 리전을 함께 수집한다.

### Major GC (Full GC)
> **트리거 조건**
> - 메모리 부족: Young Generation과 Old Generation 모두에서 메모리가 부족할 때
> - System.gc() 호출: 명시적으로 Full GC를 요청할 때
> - 기타 특정 상황에서 JVM이 전체 힙을 수집해야한다고 판단될 때
>
> **주기**
> - 힙 전체를 수집하며, 메모리 부족 또는 명시적인 요청 시 발생하며, 드물게 발생한다.























[^1]: Java HotSpot VM: Sum Microsystems(현재는 Oracle)에 의해 개발된 JVM 구현체임. Oracle JDK와 OpenJDK의 기본 JVM r구현체로 성능이 뛰어나고 안정성이 좋다.