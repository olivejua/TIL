### H3) 프로그램을 운영체제에 올리면 무슨일이 일어나는가?

- 프로그램 실행 요청
    - 사용자가 프로그램을 실행하면 운영체제는 해당 요청을 처리한다. 이는 커맨드 라인에서 명령어를 입력하거나, 아이콘을 클릭하는 등의 동작을 포함한다. (CLI, GUI)
- 프로그램 로딩
    - 운영체제는 실행 파일을 디스크에서 읽어 메모리에 로드한다.
    - 프로세스 생성 (New)
        - 프로세스 제어 블록(PCB) 생성 : 새로운 프로세스에 대한 정보를 저장하는 PCB를 생성한다. PCB에는 프로세스 ID, 프로세스 상태, 프로그램_카운터[^1], 레지스터[^2] 상태, 메모리 관리 정보 등이 포함된다.
        - 프로세스 상태 초기화: 프로세스 초기상태를 설정한다. 이는 프로그램 진입점을 설정하고, 초기 레지스터 값을 세팅하는 작업을 포함한다. (New -> Ready)
    - 스케줄링
        - CPU 스케줄러가 프로세스를 선택한다. 스케줄러는 현재 `Ready`상태에 있는 프로세스들 중에서 하나를 선택하여 실행을 준비한다. 스케줄링 알고리즘(예: 라운드로빈, 우선순위 기반 등)에 따라 프로세스가 선택된다.
    - 컨텍스트 스위칭
        - 선택된 프로세스의 PCB를 로드하여 CPU 레지스터와 프로그램 카운터를 설정한다. 이전에 실행 중이던 프로세스의 상태를 저장하고, 새로운 프로세스 상태로 전환한다. 이과정에서 CPU 레지스터와 프로그램 카운터가 새로운 프로세스의 값으로 설정된다.
            - 현재 프로세스 상태 저장: 현재 프로세스의 레지스터 값과 프로그램 카운터를 PCB에 저장한다.
            - 새 프로세스 상태 로드: 새로 실행할 프로세스의 PCB에서 레지스터 값과 프로그램 카운터를 로드한다.
    - 프로세스 실행 (Ready -> Running) : 프로그램 카운터가 가리키는 주소의 명령어를 시작한다.  프로세스는 CPU를 할당받아 실제 명령어를 수행하게 된다.
        - 프로그램 카운터 설정 : 프로그램 카운터가 새 프로세스의 진입점으로 설정된다.
        - 명령어 페치(Fetch) : CPU의 명령어 페치 단계에서 메모리에서 명령어를 가져온다.
        - 명령어 디코드(Decode) : 명령어를 디코드하여 어떤 작업을 수행해야하는지 결정한다.
    - 프로세스 실행 중
        - 프로세스는 할당된 CPU 시간을 사용하여 연속적으로 명령어를 실행한다.
        - 실행 중에 I/O 요청이나 타이머 인터럽트 등으로 인해 상태가 변경될 수도 있다.
            - I/O 요청시, 프로세스는 Waiting 상태로 전환되며, 요청이 완료되면 다시 `Ready` 상태로 돌아간다.
        - 타이머 인터럽트 등으로 인해 CPU사용시간이 종료되면, 스케줄러에 의해 다른 프로세스에게 CPU가 할당된다.
    - 프로세스 종료
        - 프로세스가 모든 작업을 완료하거나 강제 종료 요청을 받으면, `Terminated` 상태로 전환된다.
        - 운영체제는 프로세스의 자원을 해제하고, PCB를 제거한다.
        - 프로세스의 종료상태를 부모 프로세스에게 전달한다.

> [!information] 프로세스 ID 생성
> - 생성 방법: 운영체제가 프로세스를 생성할 때마다 고유한 식별번호를 부여한다. 일반적으로, PID는 순차적으로 증가하며, 이전에 사용된 PID가 재사용되기도 한다.
> - 운영체제별 차이: Unix 계열 시스템에서는 `fork()` 시스템 호출을 통해 프로세스가 생성되며, 부모 프로세스의 PID를 기준으로 새로운 PID가 할당된다. Windows에서는 `CreateProcess()` 함수가 사용된다.

> [!information] 프로세스 상태
> - New (생성) : 프로세스가 생성되고 있는 상태
> - Ready (준비) : 실행을 기다리고 있는 상태
> - Running (실행) : CPU에서 명령어를 실행 중인 상태
> - Waiting (대기) : 특정 이벤트 (예: I/O 완료)를 기다리는 상태
> - Terminated (종료) : 실행이 끝난 상태
>
>

#### H4) 프로세스 상태 업데이트
- 초기화 (New)
    - 상태: New
    - 업데이트: 프로세스가 생성되고 필요한 자원이 할당된다.
    - 변화: 생성이 완료되고 나면 Ready 상태로 전환된다.
- 실행 (Running)
    - 상태: Ready -> Running
    - 업데이트: 스케줄러가 프로세스를 선택하여 CPU를 할당한다.
    - 변화: CPU를 점유하고 명령어를 실행한다. 타임 슬라이스가 끝나거나 I/O 요청을 하면 다른상태로 전환된다.
- 대기 (Waiting)
    - 상태 : Running -> Waiting
    - 업데이트: I/O작업이나 다른 이벤트를 기다리기 위해 프로세스가 대기상태로 전환된다.
    - 변화: 이벤트가 발생하면 Ready 상태로 돌아간다.
- 종료 (Terminated)
    - 상태: Running -> Terminated
    - 업데이트: 프로세스가 작업을 완료하고 종료된다.
    - 변화: 운영체제는 종료된 프로세스의 자원을 회수하고 PID를 해제한다.

#### H4) 파일시스템이 실행파일의 위치를 어떻게 찾는가?
1. 사용자 입력 처리: CLI 또는 GUI로 프로그램 실행 요청하면 운영체제는 이를 인식하고 해당 명령을 처리한다. (예: `./myProgram`)
2. 경로 확인: 운영체제는 실행파일의 경로를 확인한다.
3. 디렉토리 트리 탐색
    1. 루트 디렉토리부터 시작 : 경로가 절대 경로인 경우 루트 디렉토리(`/`)부터 시작한다. 상대 경로인 경우 현재 작업 디렉토리에서부터 시작한다.
    2. 디렉토리 엔트리 읽기 : 디렉토리는 파일과 다른 디렉토리에 대한 엔트리를 포함한다.
        1. 예시로 `usr/bin/myProgram`을 탐색한다하면 `/`디렉토리에서 `usr` 디렉토리 엔트리를 찾는다.
        2. `/usr` 디렉토리에서 `bin` 디렉토리 엔트리를 찾는다.
        3. `/usr/bin` 디렉토리에서 `myProgram` 파일 엔트리를 찾는다.
4. 아이노드(Inode) 확인 : 파일 시스템은 각 파일과 디렉토리에 대한 메타데이터를 ==아이노드(inode)==에 저장한다. 파일 시스템은 디렉토리 엔트리를 통해 아이노드 번호를 확인하고, 아이노드 테이블에서 해당 아이노드를 읽는다.
5. 파일 존재 확인 및 접근 권한 검사
    1. 파일존재 확인: 지정된 경로에 파일이 존재하는지 확인
    2. 접근권한 검사: 파일에 대한 읽기/실행 권한이 있는지 확인한다. 이는 파일의 소유자, 그룹, 기타사용자에 대한 권한을 검사하는 과정이다.
6. 파일 핸들 생성
    1. 파일 시스템은 파일을 성공적으로 찾으면 파일 핸들을 생성한다. ==파일 핸들은 파일에 대한 참조를 유지하며==, 이후 파일 작업(읽기, 쓰기)에 사용된다.
7. 실행 파일 로드 및 실행 : 운영체제는 파일 시스템이 제공한 파일 핸들을 사용하여 실행 파일을 메모리에 로드한다.
    1. 메모리 메핑: 실행파일의 각 세션(코드, 데이터, 스택 등)을 메모리에 매핑한다.
    2. 프로세스 생성: 새로운 프로세스를 생성하고, 프로세스 제어 블록(PCB)을 초기화한다.
    3. 진입점 설정: ==실행 파일의 진입점(entry point) 주소==를 설정한다.
    4. 실행: CPU는 설정된 진입점부터 명령어를 실행하기 시작한다.



#### H4) 프로그램을 실행했을 때 프로그램을 프로세스로 만드는 애와 프로그램을 실제로 실행하는 애는 다른 애인가?

**프로그램 실행의 주체와 생성된 프로세스**
- 프로그램 실행 주체
    - 프로그램을 실행하라는 요청은 사용자에 의해 이루어지며, 이를 처리하는 것은 셸과 윈도우 매니저와 같은 기존에 실행 중인 프로세스이다.
    - 이 주체가 운영체제에 새로운 프로세스를 생성하라고 요청하는 역할을 한다.
- 생성된 프로세스
    - 운영체제는 요청을 받아 새로운 프로세스를 생성하고, 프로그램을 로드하여 실행한다.
    - 이 새로운 프로세스는 독립적인 실행단위로, 자신의 메모리 공간과 자원을 할당받아 실행한다.

**Unix 계열 시스템에서 프로그램 실행 예시**
1. 명령어 입력
    - 사용자: `./myProgram`
    - 셸(기존 프로세스): 사용자가 입력한 명령어를 인식하고, `fork()`를 호출한다.
2. 새로운 프로세스 생성
    - 셸: `fork()`를 호출하여 새로운 프로세스(자식 프로세스)를 생성한다.
    - 커널: 새로운 프로세스를 생성하고, 자식 프로세스의 PID를 반환한다.
3. 프로그램 로드 및 실행
    - 자식 프로세스: `exec()`를 호출하여, `./myProgram`을 실행한다.
    - 커널: `./myPRogram` 실행파일을 메모리에 로드하고, 자식 프로세스가 이를 실행하도록 한다.
4. 프로세스 실행
    - 자식 프로세스: `./myprogram`의 코드를 실행하여 프로그램이 수행된다.

### H3) CPU 스케줄러와 운영체제 스케줄러
> CPU 스케줄러와 운영체제 스케줄러는 사실상 동일한 개념을 가리키는 경우가 많다.
> 둘 다 프로세스나 스레드를 관리하고 실행 순서를 결정하는 역할을 한다. 그러나 때때로 더 구체적인 맥락에서 약간 다른 의미로 사용될 수 있다.

##### H5) CPU 스케줄러
- 주요기능: CPU 스케줄러는 프로세스나 스레드에게 CPU를 할당하는 역할을 한다.
- 작업: `Ready` 상태에 있는 여러 프로세스 중에서 어느 프로세스가 `Running` 상태로 전환될지를 결정한다.
- 알고리즘: 라운드로빈, 선접형 우선순위, FIFO 등이 있다.
- 동작: CPU 스케줄러는 빠르게 결정을 내려야하며, 주로 프로세스의 컨텍스트 스위치가 필요한 상황에서 작동한다.

##### H5) 운영체제 스케줄러
- 주요기능: 운영체제 스케줄러는 시스템 전체에서 실행되는 모든 작업의 스케줄링을 담당한다.
- 작업: CPU 스케줄링 뿐만 아니라, I/O 스케줄링, 메모리 스케줄링 등 다양한 자원 스케줄링을 포함할 수 있다.
- 범위: 운영체제 스케줄러는 CPU 스케줄러를 포함한 더 넓은 범위를 아우르며, 시스템의 모든 자원에 대한 접근과 사용을 조율한다.
- 예: 작업 스케줄링, 네트워크 패킷 스케줄링, 디스크 스케줄링

#### H4) I/O 스케줄링과 메모리 스케줄링이 존재하는 이유
> I/O 스케줄링과 메모리 스케줄링이 필요한 이유는 시스템 자원의 효율적인 사용과 최적 성능을 보장하기 위함이다. 단순히 현재 `Running` 상태인 프로세스에만 자원을 맞추는 것은 한계가 있으며, 여러 프로세스가 동시에 실행되고 자원을 요청하는 현실적인 시나리오에서는 다양한 자원 스케줄링이 필수적이다.

##### H5) I/O 스케줄링의 필요성
**1. 자원 경쟁**
- 여러 프로세스가 동시에 I/O 요청을 할 수 있다. 이를 조율하지 않으면 자원 경정으로 인해 병목 현상이 발생할 수 있다.
  **2. 효율성**
- 디스크와 같은 I/O 자원은 접근 시간이 비교적 느리기 때문에 효율적으로 스케줄링하지 않으면 전체 시스템 성능이 저하될 수 있다.
  **3. 공평성**
- 특정 프로세스가 자원을 독점하지 않도록 공평하게 I/O 자원을 분배해야한다.

##### H5) 메모리 스케줄링의 필요성
**1. 메모리 자원 제한**
- 시스템 메모리는 한정적 자원이다. 여러 프로세스가 동시에 메모리를 요청할 때 이를 적절히 분배해야 한다.
  **2. 페이지 교체**
- 메모리가 가득차면 페이지 교체 알고리즘을 사용하여 적절한 페이지를 교체해야 한다. 이를 통해 페이지 폴트를 최소화할 수 있다.
  **3. 효율적인 메모리 사용**
- 메모리 단편화를 줄이고, 가용 메모리를 최대한 활용해야한다.

### H3) 운영체제 실행 대기열
> 역할 : 실행 대기열은 `Ready` 상태에 있는 모든 프로세스의 목록을 유지한다. 이 목록은 CPU 스케줄러가 다음에 실행할 프로세스를 선택하는데 사용된다.
> 구조: 실행 대기열은 큐 (queue) 자료구조로 구현되며, 다양한 스케줄링 알고리즘에 따라 프로세스가 추가되고 제거된다.

메모리 사용
- 운영체제 메모리: 실행 대기열은 운영체제가 사용하는 메모리 공간의 일부이다. 운영체제는 시스템 메모리 중 일부를 커널 공간으로 할당받아 이러한 데이터 구조를 유지한다.
- 커널 공간: 실행 대기열을 포함한 다양한 커널 데이터 구조와 자원은 커널 공간에서 관리된다. 이 공간은 사용자 공간과 구분되며, 사용자 프로세스는 직접 접근할 수 없다.

#### H4) 운영체제가 동작하는것도 CPU가 해야하는일인데 이것도 프로세스가 있는건가?
> 운영체제가 동작하는 것도 CPU가 실행해야하는 작업이다. 운영체제의 기능도 코드로 작성되어 있으며, 이 코드도 CPU에 의해 실행된다. 이를 이해하기 위해 운영체제의 구조와 동작 방식을 자세히 살펴보아야한다.

##### H5) 운영체제의 구성
1. 커널(Kernel) : 운영체제의 핵심 부분으로, 시스템 자원 관리, 프로세스 관리, 메모리 관리, 파일시스템 등이 있다.
2. 드라이버(Drivers): 하드웨어 장치를 제어하고, 운영체제와 하드웨어 간의 인터페이스를 제공한다.
3. 시스템 호출 인터페이스 (System Call Interface) : 사용자 프로세스가 운영체제의 기능을 사용할 수 있도록 인터페이스를 제공한다.
##### H5) 운영체제의 동작
운영체제의 코드도 결국은 CPU에 의해 실행된다. 운영체제 자체는 하나의 거대한 프로세스로 간주될 수 있다.
다만, 운영체제의 각 부분은 특수한 권한을 가지고 있으며, 사용자 프로세스와 구분되어 동작한다.

**1. 커널모드와 사용자 모드**
- 커널 모드: 운영체제가 실행하는 모드로, 모든 하드웨어 자원에 접근할 수 있다. 커널 코드가 실행될 때는 CPU가 이 모드로 전환된다.
- 사용자 모드: 일반 사용자 프로세스가 실행되는 모드로, 제한된 자원만 접근할 수 있다. 사용자 모드에서 실행 중인 프로세스가 시스템 자원에 접근하려면 시스템 호출을 통해 커널모드로 전환된다.

**2. 운영체제의 실행**
- 인터럽트와 시스템 호출: 사용자 프로세스가 시스템 자원에 접근하거나 특정 작업을 요청할 때, 시스템 호출을 통해 커널 모드로 전환된다. 이 때 CPU는 운영체제의 커널 코드를 실행한다.
- 프로세스 관리 : 운영체제는 프로세스 스케줄링, 생성, 종료 등의 작업을 수행한다. 이는 모두 CPU에 의해 실행되는 코드이다.

##### H5) 운영체제와 CPU의 관계
**1. 시스템 부팅**
- 컴퓨터가 커지면, BIOS나 UEFI가 운영체제를 메모리에 로드한다.
- CPU는 부트 로더와 커널 코드를 실행하여 운영체제를 초기화한다.

**2. 운영체제의 주기적 동작**
- 타이머 인터럽트 : 주기적으로 발생하는 타이머 인터럽트를 통해 CPU가 커널 코드를 실행하여 프로세스를 스케줄링한다.
    - 운영체제는 타이머 인터럽트를 통해 주기적으로 CPU 제어권을 획득한다. 이 시점에서 스케줄러는 현재 실행중인 프로세스를 중단하고, 실행 대기열에 있는 다른 프로세스를 선택하여 실행할 수 있다.
- I/O 인터럽트: I/O 작업이 완료되면, 인터럽트가 발생하여 CPU가 커널 코드를 실행한다.

**3. 시스템 호출 처리**
- 사용자 프로세스가 시스템 호출을 하면, CPU는 커널 모드로 전환되어 해당 시스템 호출을 처리한다.

> 운영체제 자체도 CPU에 의해 실행되지만, 일반 사용자 프로스세와는 다른 특권을 가지고 있다. 운영체제 커널은 항상 메모리에 상주하며, 필요한 경우 CPU에 의해 실행된다.
> 따라서 운영체제의 각 부분은 프로세스처럼 CPU에 의해 스케줄링되지만 사용자 프로세스와는 구분되어 동작한다.
>
> 운영체제는 주기적인 타이머 인터럽트와 다양한 이벤트 (시스템 호출, 하드웨어 인터럽트 등)에 의해 CPU 제어권을 획득하고, 커널 코드를 실행하여 필요한 작업을 수행한다. 이 과정에서 스케줄러는 프로세스를 관리하고, 자원을 효율적으로 할당하여 시스템의 안정성과 성능을 보장한다. 따라서 운영체제의 동작은 CPU에 의해 주기적으로 또는 이벤트에 의해 커널 코드가 실행되면서 이루어진다.

##### H5) CPU에 의해 디스크나 메모리에 접근하는건가?
> CPU에 의해 메모리에 접근하는 것 맞음

```
  +---------------------+       +-----------------+
  |      CPU            |       |   Disk          |
  | +-----------------+ |       | +-------------+ |
  | | Registers       | |       | | Disk Driver | |
  | +-----------------+ |       | +-------------+ |
  | | ALU             | |       | | Disk Data   | |
  | +-----------------+ |       | +-------------+ |
  +---------------------+       +-----------------+
           |                             |
           |                             |
           v                             v
  +---------------------+       +-----------------+
  |    System Bus       |<----->|   I/O Bus       |
  +---------------------+       +-----------------+
           ^                             ^
           |                             |
           |                             |
  +---------------------+       +-----------------+
  |      Memory         |       |   I/O Device    |
  | +-----------------+ |       | +-------------+ |
  | | RAM             | |       | | Device Driver| |
  | +-----------------+ |       | +-------------+ |
  | | Memory Controller| |       | | Device Data | |
  | +-----------------+ |       | +-------------+ |
  +---------------------+       +-----------------+
```

###### H6) 메모리 접근 과정
- CPU가 명령을 실행할 때
    - CPU는 메모리 컨트롤러를 통해 RAM에 접근한다.
    - 메모리 컨트롤러는 시스템 버스를 통해 RAM에서 데이터를 읽거나 쓴다.
- CPU -> 메모리 접근 단계
    - 명령어 페치 (Fetch): CPU는 프로그램 카운터(CPU)가 가리키는 메모리 주소에서 명령어를 가져온다.
    - 명령어 디코드 (Decode) : 가져온 명령어를 해석한다.
    - 명령어 실행 (Execute) : 필요한 경우 추가 데이터를 메모리에서 읽거나, 연산 결과를 메모리에 쓴다.

###### H6) I/O 이벤트 발생 과정
- I/O 요청 발생
    - CPU는 특정 I/O 장치와의 데이터 전송을 위에 시스템 호출을 통해 I/O 요청을 발생시킨다.
- I/O 컨트롤러로 신호전달
    - CPU는 I/O 컨트롤러를 통해 I/O 장치에 접근한다.
    - I/O 컨트롤러는 I/O 버스를 통해 해당 장치와 통신한다.
- I/O 작업 수행:
    - I/O 장치는 데이터를 처리하고, 필요한 경우 디스크 등의 저장 장치와 데이터를 주고받는다.
    - 작업 완료후 I/O장치는 인터럽트를 발생시켜 CPU에 작업완료를 알린다.
- 인터럽트 처리
    - 인터럽트 발생 : I/O 장치가 작업을 완료하면 인터럽트를 발생시킨다.
    - CPU 인터럽트 처리: CPU가 현재 작업을 중단하고, 인터럽트 벡터를 통해 인터럽트 핸들러로 점프한다.
    - 인터럽트 핸들러 실행: 인터럽트 핸들러가 실행되어 I/O 작업 완료를 처리하고, 필요한 후속 작업을 수행한다.
    - 원래 작업으로 복귀: 인터럽트 처리가 끝나면 CPU는 원래 작업으로 돌아가 계속 실행한다.

###### H6) I/O 컨트롤러란?
> 컴퓨터 시스템에서 CPU와 I/O 장치간의 인터페이스 역할을 하며, 일반적으로 **메인보드에 위치**해있다. 각 I/O 장치는 자신의 컨트롤러를 가지며, 이 컨트롤러는 시스템 버스와 연결되어 있다.

**1. 위치**
- I/O 컨트롤러는 메인보드에 장착된 칩셋이 일부로서 존재한다. 이 컨트롤러는 다양한 I/O 장치(디스크 드라이브, 키보드, 마우스, 네트워크 어댑터 등)를 관리한다. 각 I/O 장치는 메인보드의 확장 슬롯이나 포트를 통해 I/O컨트롤러에 연결된다.

**2. CPU와 I/O 장치간의 인터페이스**
- CPU는 시스템 버스를 통해 I/O 컨트롤러에 명령을 전송한다.
- I/O 컨트롤러는 해당 명령을 받아 I/O 장치로 전달하고, 장치의 응답을 다시 CPU에 전달한다.
- 예를 들어, 디스크 읽기/쓰기 요청, 네트워크 패킷 송수신 등이 I/O 컨트롤러를 통해 처리된다.

**3. I/O 컨트롤러의 구성**
- 제어로직 : I/O 장치의 상태를 감시하고, CPU의 명령을 해석하여 적절한 I/O 작업을 수행한다.
- 데이터 버퍼 : 데이터 전송 중에 데이터를 임시로 저장하여 CPU와 I/O 장치간의 데이터 흐름을 조절한다.
- 인터럽트 제어 : I/O 작업 완료시 CPU에 인터럽트를 발생시켜 작업 완료를 알린다.


> [!question] I/O 에 들어가는 절차와 네트워크 송수신에 들어가는 절차가 어떻게 될까? (비용이 왜 많이 나오는걸까?)




```
  +--------------------------------------+
  |                CPU                   |
  +--------------------------------------+
                    |
                    |
            +------------------+
            |  System Bus      |
            +------------------+
                    |
  +-----------------+-----------------+
  |                                   |
  v                                   v
+---------------------+       +---------------------+
|    Memory           |       |    I/O Controller   |
| +-----------------+ |       | +-----------------+ |
| | RAM             | |       | | Control Logic   | |
| +-----------------+ |       | +-----------------+ |
| | Memory Controller| |       | | Data Buffer     | |
| +-----------------+ |       | +-----------------+ |
+---------------------+       | | Interrupt Control| |
                               | +-----------------+ |
                               +---------------------+
                                         |
        +--------------------------------+---------------------------+
        |                                |                           |
        v                                v                           v
+--------------+           +---------------------+      +---------------------+
|  Disk Drive  |           |  Network Adapter    |      |  Keyboard/Mouse     |
+--------------+           +---------------------+      +---------------------+

```








- [^1]: 프로그램 카운터(Program Counter, PC) : **다음에 실행될 명령어의 주소를 가리킴**. CPU는 프로그램 카운터의 값을 참조하여 명령어를 순차적으로 실행한다. 명령어가 실행될 때마다 프로그램 카운터는 다음 명령어의 주소를 자동으로 증가하거나, 분기 명령어에 의해 다른 주소로 업데이트된다.
- [^2]: 레지스터 (Register) : **CPU 내부에 있는 고속 메모리**로, 연산을 빠르게 수행하기 위해 데이터를 저장하고 접근하는데 사용된다. 종류로는 일반 목적 레지스터(데이터 연산용), 특수 목적 레지스터(명령어 레지스터(현재 실행중인 명령어), 스택 포인터(스택의 최상위 주소 가리킴), 플래그 레지스터(연산 결과의 상태)) 가 있다.